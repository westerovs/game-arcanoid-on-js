

/*
                          1 
  - cоздать глобальную переменную с настройкой запуска и остановки игры
*/


/*
                          2 
  - распределить логику в объекте по своим ключам
  - вынести всё в ключ старт
  - сделать цикл рендера изобрежений. из объекта
  - проверять загрузились ли изображения, прежде чем рендерить их
*/

/*
                          3 рендер блоков
  - удостовериться что у нас не объявляются функции внутри циклов. (bad practics)
  - в объект спрайты добавляем block
  - добавляем ключ rows, cols и массив blocks: []
  - в методе рендер перебираем массив this.blocks и в нем вызываем drawImage блоков
  - завести новый метод create и запустить его в start, перед run
  - в методе create мы двойным циклом пушим в массив наши блоки. При пуше создаем объект
    с координатами x and y
*/

/*
                          4 движение платформы
  - в методе init вызываем метод setEvents, который отвечает за нажатие клавиш
  - сравниваем какая клавиша нажата и по нажатии перерисовываем канвас, для этого в метод 
    run переносим requestAnimFrame и вызываем рекурсию run()
  - в объекте платформы завести ключ velocity и ключ dx - смещение в данный момент
  - (1)* в методе run проверяем - если платформа имеет скорость, то координата платформы 
    возрастает с этой скоростью
  - изменять скорость платформы при нажатии на кливиши
  - добавить обработчик отпускания кнопки - остановка платформы (dx = 0)
                          рефакторинг
  - перенести условие (1)* в отдельный метод move() внутри game.platform
    и вызывать его в run
  - завести метод update и вызывать в нём this.platform.move()
*/
























// кадрирование
// 1 - img, 
// 2 - sx, sy, кадрирование
// 3 -  sWidth, sHeight ширина и высота отрис. участка
// 4 - dx, dy координаты на поле канваса
// 5 -  dWidth, dHeight ширина и высота на канвасе
// void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);

// Очистить канвас от наслаивания
ctx.clearRect(x, y, w, h);

// СТОЛКНОВЕНИЕ ОБЪЕКТОВ 
// 1 - спрайт это всегда четырёхугольник. Об этом стоит всегда помнить
// что бы проверить что один спрайт находит на другой, то должно сойтись 4 условия:
// положение координат каждой из сторон относительно друг-друга
// т.е =
// 1 верхняя сторона мяча - выше чем нижняя сторона прямоугольника
// 2 правая сторона мяча - правее чем левая сторона прямоугольника
// 3 левая сторона мяча - левее чем правая сторона прямоугольника
// 4 нижняя сторона мяча - ниже чем верхняя сторона прямоугольника
// Эти 4 условия выполняются всегда, с какой бы стороны мяч не подлетел

// правая сторона мяча - это его ширина
// - сначала получаем координату x блока и добавляем к ней ширину

// левая сторона мяча - это его координата

// нижняя сторона мяча -  это его координата по Y + высота


// верхняя сторона мяча -  это его координата по Y + element.y + element.height

// проверить что правая сторона мяча, правее чем левая сторона блока
collide(element) {
  // от бага с шаром в текстурах
  // проверяем на столкн. коорд мяча на след.кадре анимации
  // коорд.мяча текущ + его смещение к след.кадру
  let x = this.x + this.dx;
  let y = this.y + this.dy;

  if (
    x + this.width > element.x &&
    x < element.x + element.width &&
    y + this.height > element.y &&
    y < element.y + element.height) {
    return true;
  }

  return false;

};


// добавить аудио
new Aydio('путь');
addEventListener('canplaythrough', onImageLoad);

// добавить текст
this.fillText('Score', x, y);
this.fillStyle = '#FFFFFF' // цвет
this.fotn = '20px Arial'































